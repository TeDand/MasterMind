#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <cmath>

/// you can add other headers as needed
/// but only headers from the standard library
/// and not the algorithm header

/// do not use using namespace std

/// functions for random number generation, do not alter the declarations
void set_random_seed();
int randn(int n);

/// you can define and use additional functions and structs,
/// add here the declarations for any other functions
/// and/or structs you wish to define and use
/// (the implementation for functions that don't belong to a struct
/// should be added after the main)

/// this is the struct definition for the code maker
/// do not alter the name
struct mm_code_maker{

    /// this member function sets the values for the member data
    /// representing the length of the code
    /// and the number of symbols (the symbols will be 0 to i_num - 1)
    /// (this should be a constructor in proper OOP but ok)
    /// do not alter this function
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }

    /// this member function generates a random sequence based
    /// on the length and num parameters stored as member data
    /// do not alter this function
    void generate_sequence(){
      for(int i = 0; i < length; i++){
          sequence.push_back(randn(num));
      }
    }

    /// do not alter the function interface (name, parameter list, void return)
    void give_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){
        /// write here your implementation for this function
        /// which takes in input an attempt
        /// and provides feedback in terms of black hits
        /// and white hits (see linked paper)
        black_hits = 0;
        white_hits = 0;
        int total_hits = 0, codeword_occurence, attempt_occurence;

        for(int i = 0; i < length; i++){
          if (sequence[i] == attempt[i]) {
            black_hits += 1;
          }
        }

        for(int i = 0; i < num; i++){
          codeword_occurence = 0;
          attempt_occurence = 0;

          for (int j = 0; j < length; j++) {
            if (sequence[j] == i) {
              codeword_occurence += 1;
            }
            if (attempt[j] == i) {
              attempt_occurence += 1;
            }
          }

          if (codeword_occurence < attempt_occurence) {
            total_hits += codeword_occurence;
          }
          else {
            total_hits += attempt_occurence;
          }
        }

        white_hits = total_hits - black_hits;
    }

    /// member data holding the sequence generated by generate_sequence
    /// do not alter this
    std::vector<int> sequence;

    /// member data holding the values for length of code and number of symbols
    /// do not alter these
    int length;
    int num;

    /// do not add any other member data,
    /// in particular note that any variables needed for function give_feedback
    /// need to be declared within give_feedback
    /// (they are not member data of the struct)

    /// you may add other member functions if needed
};


/// this is the struct definition for the solver, do not alter the name
struct mm_solver{

    /// this member function sets the values for the member data
    /// representing the lenght of the code
    /// and the number of symbols (the symbols will be 0 to i_num - 1)
    /// (this should be a constructor in proper OOP but ok)
    /// do not alter the function interface (name, parameter list, void return)
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
        prev_black_hits = length + 1;
        index1 = 0;
        index2 = 0;
        first = 1;
        preGen = 1;
        if (pow(num, length) < pow (6, 6)) {
          approach = 1;
        }
        else if ((pow(num, length) >= pow (6, 6))&&(pow(num, length) <= pow (8, 8))) {
          approach = 2;
        }
        else {
          approach = 3;
        }
        // array, size, n
        /// you can include additional implementation lines here if needed

    }

    /// this member function creates an attempt to find
    /// the right code
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void create_attempt(std::vector<int>& attempt){
        /// write your implementation here
        if (approach == 1) {
          if (first) {
            for(int i = 0; i < length; i++){
             attempt.push_back(randn(num));
            }
          first = 0;
          }
          else {
            attempt = possible[bestNextChoice];
          }
        }

        if (approach == 2) {
          if (first) {
            for (int i = 0; i < length; i++) {
              attempt.push_back(0);
            }
            first = 0;
          }
          else if (preGen) {
            int pushNum = attempt[0] + 1;
            attempt.clear();
            for (int i = 0; i < length; i++) {
              attempt.push_back(pushNum);
            }
          }
          else {
            if (possible.empty()) {
              attempt.clear();
              allocate_posNums();
              for(int i = 0; i < length; i++){
                attempt.push_back(possibleNums[i]);
              }
            }
            else {
              attempt = possible[bestNextChoice];
            }
          }
        }

        if (approach == 3) {
          if (first) {
            for (int i = 0; i < length; i++) {
              attempt.push_back(0);
            }
            first = 0;
          }
          else if (preGen) {
            int pushNum = attempt[0] + 1;
            attempt.clear();
            for (int i = 0; i < length; i++) {
              attempt.push_back(pushNum);
            }
          }
          else {
            if (presentNums.empty()) {
              attempt.clear();
              for (int i = 1; i < numOccurences.size(); i++) {
                if (numOccurences[i] != 0) {
                  presentNums.push_back(i);
                }
                attempt.push_back(0);
              }
              attempt.push_back(0);
            }
            else {
              attempt[index1] = presentNums[index2];
            }
          }
        }
    }

    /// this member function acquires the feedback about a certain attempt
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void learn(std::vector<int>& attempt, int black_hits, int white_hits){
        /// write your implementation here
        if (black_hits < length) {
          std::vector<std::vector<int> > tmp;

          if (approach == 1) {
            if (dummyPermutation.empty()) {
              for (int i = 0; i < length; i++) {
                dummyPermutation.push_back(0);
              }
              allocate_posNums();
              permutations(0 , dummyPermutation);
            }

            for (int i = 0; i < possible.size(); i++) {
              if ((feedback_match(attempt, possible[i], black_hits, white_hits)) && (possible[i] != attempt)) {
                tmp.push_back(possible[i]);
              }
            }

            possible = tmp;
            bestNextChoice = best_choice(black_hits, white_hits);
          }

          if (approach == 2) {
            if (preGen) {
              numOccurences.push_back(black_hits);
              if (numOccurences.size() == num) {
                preGen = 0;
              }
            }
            else {
              if (possible.empty()) {
                permutations2(possibleNums.size(), possibleNums);
              }

              for (int i = 0; i < possible.size(); i++) {
                if ((feedback_match(attempt, possible[i], black_hits, white_hits)) && (possible[i] != attempt)) {
                  tmp.push_back(possible[i]);
                }
              }

              possible = tmp;
              bestNextChoice = best_choice(black_hits, white_hits);
            }
        }

        if (approach == 3) {
          if (preGen) {
            numOccurences.push_back(black_hits);
            if (numOccurences.size() == num) {
              preGen = 0;
              attempt.clear();
            }
          }
          else {
            if (prev_black_hits > length) {
              prev_black_hits = black_hits;
            }
            else {
              if (black_hits > prev_black_hits) {
                prev_black_hits = black_hits;
                index1 += 1;
                index2 = 0;
              }
              else if (prev_black_hits > black_hits) {
                if (index2 == 0) {
                  attempt[index1] = 0;
                }
                else {
                  attempt[index1] = presentNums[index2-1];
                }
                index1 += 1;
                index2 = 0;
              }
              else if (prev_black_hits == black_hits) {
                  index2 += 1;
              }
            }
          }
      }
    }


    }

    int best_choice(int black_hits, int white_hits) {
      int bestIndex = 0, possibilities, leastPossibilities = 0;

      bestIndex = randn(possible.size());

      return bestIndex;
    }

    void allocate_posNums() {
      if (approach == 1) {
        for (int i = 0; i < num; i++) {
          possibleNums.push_back(i);
        }
      }

      if (approach == 2) {
        for (int i = 0; i < numOccurences.size(); i++) {
          for (int j = 0; j < numOccurences[i]; j++) {
            possibleNums.push_back(i);
          }
        }
      }
    }

    void permutations(int n, std::vector<int> tmp) {
      if (length == n) {
        possible.push_back(tmp);
        return;
      }
      for (int i = 0; i < possibleNums.size(); i++) {
        tmp[n] = possibleNums[i];
        permutations(n+1, tmp);
      }
    }

    void permutations2(int n, std::vector<int> v) {
      if(n == 1) {
        bool added = 0;
        for (int i = 0; i < possible.size(); i++) {
          if (v == possible[i]) {
            added = 1;
          }
        }
        if (added == 0) {
          possible.push_back(v);
        }
        return;
      }
      for(int i = 0;i < n;i++) {
        swap(v[i], v[n-1]);  // (removes the ith element)
        permutations2(n-1,v);
        swap(v[i], v[n-1]);  // (restore for the next round)
      }
    }

    void swap(int& n1, int& n2) {
      int temp;
      temp = n1;
      n1 = n2;
      n2 = temp;
    }

  bool feedback_match(const std::vector<int>& attempt, const std::vector<int>& newAttempt, int black_hits, int white_hits) {
    int newAttempt_black_hits = 0;
    int newAttempt_white_hits = 0;
    int newAttempt_occurence, attempt_occurence, total_hits = 0;

    for(int i = 0; i < length; i++){
        if (attempt[i] == newAttempt[i]) {
          newAttempt_black_hits += 1;
        }
    }

    for(int i = 0; i < num; i++){
      newAttempt_occurence = 0;
      attempt_occurence = 0;

      for (int j = 0; j < length; j++) {
        if (attempt[j] == i) {
          attempt_occurence += 1;
        }
        if (newAttempt[j] == i) {
          newAttempt_occurence += 1;
        }
      }

      if (attempt_occurence < newAttempt_occurence) {
        total_hits += attempt_occurence;
      }
      else {
        total_hits += newAttempt_occurence;
      }
    }

    newAttempt_white_hits = total_hits - newAttempt_black_hits;

      if ((newAttempt_black_hits == black_hits)&&(newAttempt_white_hits == white_hits)) {
        return 1;
      }
      else {
        return 0;
      }
    }

    int length;
    int num;
    int bestNextChoice;
    std::vector<std::vector<int> > possible;
    std::vector<int> dummyPermutation;
    std::vector<int> possibleNums;
    std::vector<int> numOccurences;
    std::vector<int> presentNums;
    int prev_black_hits;
    int index1, index2;
    bool first, preGen;
    int approach;

    /// you may add other member functions and member data as needed
    /// (keep in mind the distinction between member function variables
    /// and member data of the struct)

};

// int main(){
//     /// write the code for the main here in order to test your functions
//     /// the main is not relevant for this assignment and we will remove it
//     /// from the submissions during the marking
//     int length, num;
//     std::cout << "enter length of sequence and number of possible values:" << std::endl;
//     std::cin >> length >> num;
//
//     set_random_seed();
//
//     mm_solver solver;
//     /// we declare an object of type mm_solver
//     solver.init(length, num);
//     /// we initialise the values for length and num
//
//     mm_code_maker maker;
//     /// we declare an object of type mm_code_maker
//     maker.init(length, num);
//     /// we initialise the values for length and num
//
//     maker.generate_sequence();
//     /// we generate a random sequence
//
//     int black_hits=0, white_hits=0;
//     int attemptCount = 0;
//
//     std::vector<int> attempt;
//
//     while (black_hits < length) {
//       attemptCount += 1;
//
//       solver.create_attempt(attempt);
//
//       std::cout << "Attempt " << attemptCount << ": ";
//       for (int i = 0; i < attempt.size(); i++) {
//         std::cout << attempt[i] << " ";
//       }
//       std::cout << std::endl;
//
//       maker.give_feedback(attempt, black_hits, white_hits);
//
//       std::cout << "White hits: " << white_hits << std::endl;
//       std::cout << "Black hits: " << black_hits << std::endl;
//
//       solver.learn(attempt, black_hits, white_hits);
//
//       std::cout << std::endl;
//     }
//
//     return 0;
// }

/// not a great implementation for set_random_seed and for randn;
/// if you are trying to get better results you may want to change
/// the implementation using C++11 features, see for instance
/// https://isocpp.org/files/papers/n3551.pdf
/// but don't change the interface/declaration of the functions

void set_random_seed(){
    std::srand(std::time(0));
}

int randn(int n){
    return std::rand() % n;
}

/// add here the implementation for any other functions you wish to define and use
